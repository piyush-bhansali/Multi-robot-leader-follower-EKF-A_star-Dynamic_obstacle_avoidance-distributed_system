function [v, omega] = followerPurePursuit(follower1Ekf, desiredFollower1Pose, error, PID, robot)
    % Extract robot pose from EKF state
    robot_pose = follower1Ekf.state;  % Since follower1Ekf contains the state vector

    % Calculate distance to desired pose
    distance = norm(robot_pose(1:2) - desiredFollower1Pose(1:2));

    % Base velocity calculation
    v = min(robot.maxSpeed, distance / 0.1);

    % PID controller for velocity adjustment
    v = v + PID.Kp1 * error.previousError + PID.Ki1 * error.integralError + PID.Kd1 * error.derivativeError;
    
    % Clamp velocity within bounds
    v = max(0, min(v, robot.maxSpeed));

    % Calculate desired heading
    desired_heading = atan2(desiredFollower1Pose(2) - robot_pose(2), ...
                          desiredFollower1Pose(1) - robot_pose(1));

    % Calculate steering angle (normalized between -π and π)
    steering_angle = atan2(sin(desired_heading - robot_pose(3)), ...
                          cos(desired_heading - robot_pose(3)));

    % Calculate angular velocity
    omega = v * tan(steering_angle) / robot.wheelBase;
    disp('v');
    disp(v);
    disp('omega');
    disp(omega);

    % Add safety checks
    if isnan(v) || isnan(omega)
        warning('NaN values detected in follower control!');
        v = 0;
        omega = 0;
    end

    % Add minimum distance check
    min_safe_distance = robot.robotRadius * 2;
    if distance < min_safe_distance
        v = 0;  % Stop if too close
        omega = robot.maxSpeed * tan(steering_angle) / robot.wheelBase;;
    end

end
